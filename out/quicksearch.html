<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"core.js.html":{"id":"core.js.html","title":"Source: core.js","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Source: core.js &quot;use strict&quot;; /** * Interfaces to operate UTab core * @module core * @author taulukointipalvelut@gmail.com (nswa17) * @file Interfaces to manage tournament * @todo simple allocation * @version 1.1 * @example * var core = require('./core.js') * * var t_id = 234234 * core.tournaments.read().then(console.log) //print all tournaments * core.tournaments.create({id: t_id, name: &quot;testtournament&quot;}) * core.connect(t_id) * core.teams.read().then(console.log) //print all teams */ let operations = require('./src/operations.js') let controllers = require('./src/controllers.js') let _ = require('underscore/underscore.js') let con = new controllers.CON() let op = new operations.OP() /** * Represents a pair/set of teams in a venue. A minimum unit to be an allocation. * @typedef Square * @property {Number} id id of the Square * @property {Number[]} teams teams in the Square * @property {Number[]} chairs chairs in the Square * @property {Number[]} remaining_adjudicators adjudicators(panels) in the Square * @property {Number[]} remaining_adjudicators2 adjudicators(trainees) in the Square * @property {String[]} warnings warnings * @property {Number} venue */ /** * Represents a team. * @typedef Team * @property {Number} id id of the Team * @property {String} name name of the Team * @property {Boolean} available available * @property {String} url url of the Team */ /** * Represents an adjudicator. * @typedef Adjudicator * @property {Number} id id of the Adjudicator * @property {Number} preev pre evaluation(judge test) of the Adjudicator * @property {String} name name of the Adjudicator * @property {Boolean} available available * @property {String} url url of the Adjudicator */ /** * Represents a venue. * @typedef Venue * @property {Number} id id of the Venue * @property {Number} priority priority of the Venue * @property {String} name name of the Venue * @property {Boolean} available available * @property {String} url url of the Venue */ /** * Represents an institution. * @typedef Institution * @property {Number} id id of the Institution * @property {String} name name of the Institution * @property {Boolean} available available * @property {String} url url of the Institution */ /** * Represents raw team result. * @typedef RawTeamResult * @property {Number} id id of the team to evaluate * @property {Number} from_id id of the sender * @property {Number} r round number at which the result is sent * @property {Number} win in NA it's either 1(win) or 0(lose), in BP it's the win-points * @property {Number[]} opponents opponents of the team * @property {String} side side of the team * @example * { * id: 1, * from_id: 2, * r: 1, * win: 1, * opponents: [2], * side: &quot;gov&quot; * } */ /** * Represents raw debater result. * @typedef RawDebaterResult * @property {Number} id id of the debater to evaluate * @property {Number} from_id id of the sender * @property {Number} r round number at which the result is sent * @property {Number[]} scores scores the sender writes * @example * { * id: 1, * from_id: 2, * r: 1, * scores: [75, 0, 36.5] * } */ /** * Represents raw adjudicator result. * @typedef RawAdjudicatorResult * @property {Number} id id of the adjudicator to evaluate * @property {Number} from_id id of the sender * @property {Number} r round number at which the result is sent * @property {Number} score the score of the adjudicator the sender writes * @property {Number[]} watched_teams teams the adjudicator watched * @property {String} [comment] the comment for the adjudicator from the sender */ /** * Represents debate style. * @typedef Style * @property {String} name style name * @property {Number} debater_num_per_team number of debaters per team * @property {Number} team_num number of team in a [Square]{@link Square} * @property {Number[]} score_weights weights of the scores * @property {Number} replies candidates of replies (Necessary only for testing) * @property {Number} reply_num number of replies in a [Square]{@link Square} (Necessary only for testing) * @example * { * name: &quot;ASIAN&quot;, * debater_num_per_team: 3, * team_num: 2, * score_weights: [1, 1, 1, 0.5], * replies: [0, 1], * reply_num: 1 * } */ /** * Represents a tournament. * @typedef Tournament * @property {Number} id id of the tournament * @property {String} name name of the tournament * @property {String} url url of the tournament * @property {Number} current_round_num current round * @property {Number} total_round_num total round * @property {Style} style style of the tournament */ /** * @param {Number} id - Unique ID of the tournament */ /** * connects to tournament database specified * @param {Number} id unique id of the tournament */ function connect(id) { con.connect(id) } /** * close connection on tournament database */ function close() { con.close() } /** * Provides Interfaces related to tournaments * @namespace tournaments */ /** * @name tournaments.read * @memberof! tournaments * @return {Promise.&lt;Tournament[]&gt;} */ /** * @name tournaments.create * @memberof! tournaments * @function tournaments.create */ /** * @name tournaments.update * @memberof! tournaments * @function tournaments.update */ /** * @name tournaments.delete * @memberof! tournaments * @function tournaments.delete */ var tournaments = con.tournaments /** * Provides Interfaces related to teams * @namespace teams */ var teams = con.teams /** * returns all teams(No side effect) * @name teams.read * @memberof! teams * @function teams.read * @return {Promise.&lt;Team[]&gt;} Teams */ /** * creates specified team. * Attention: It throws an error if the specified team already exists. * @name teams.create * @memberof! teams * @function teams.create * @param dict * @param {Number} dict.id id of the team to create * @param {Number} [dict.name=&quot;&quot;] name of the team to create * @param {Number} [dict.available=true] id of the team to create * @param {Number} [dict.url=&quot;&quot;] id of the team to create * @return {Promise.&lt;Team&gt;} Created team * @throws {Promise} AlreadyExists */ //this.teams.create /** * deletes specified team. * Attention: It throws an error if the specified team does not exist. * @name teams.delete * @memberof! teams * @function teams.delete * @param dict * @param {Number} dict.id id of the team to delete * @return {Promise.&lt;Team&gt;} Deleted team * @throws {Promise} DoesNotExist */ /** * finds on specified condition(No side effect) * @name teams.find * @memberof! teams * @function teams.find * @param dict * @param {Number} [dict.id] id of the team to find * @param {Number} [dict.name] name of the team to find * @param {Number} [dict.available] id of the team to find * @param {Number} [dict.url] id of the team to find * @return {Promise.&lt;Team[]&gt;} Teams */ /** * updates specified team * Attention: It throws an error if the specified team does not exist. * @name teams.update * @memberof! teams * @function teams.update * @param dict * @param {Number} dict.id id of the team to update * @param {Number} [dict.name=&quot;&quot;] name of the team to update * @param {Number} [dict.available=true] id of the team to update * @param {Number} [dict.url=&quot;&quot;] id of the team to update * @return {Promise.&lt;Team&gt;} Updated team * @throws DoesNotExist */ /** * @namespace teams.results * @memberof teams */ /** * reads all raw team results(No side effect) * @name teams.results.read * @memberof! teams.results * @function teams.results.read * @returns {Promise.&lt;RawTeamResult[]&gt;} */ /** * Summarizes team results(No side effect) * @alias teams.results.organize * @param {(Number | Number[])} r_or_rs round number(s) used to summarize results * @param options options for summarization * @param {Boolean} options.simple only use team results. No debater results is considered thus unable to output team points * @return {Promise} summarized team results */ teams.results.organize = function(r_or_rs, {simple: simple}={simple: false}) { if (simple) { if (Array.isArray(r_or_rs)) { return Promise.all([con.teams.read(), con.teams.results.read()]).then(function (vs) { var [teams, raw_team_results] = vs return op.teams.results.simplified_compile(teams, raw_team_results, r_or_rs) }) } else { return Promise.all([con.teams.read(), con.teams.results.read()]).then(function (vs) { var [teams, raw_team_results] = vs return op.teams.results.simplified_summarize(teams, raw_team_results, r_or_rs) }) } } else { if (Array.isArray(r_or_rs)) { return Promise.all([con.teams.read(), con.teams.debaters.read(), con.teams.debaters.read(), con.teams.results.read(), con.debaters.results.read(), con.rounds.read()]).then(function (vs) { var [teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, round_info] = vs return op.teams.results.compile(teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, round_info.style, r_or_rs) }) } else { return Promise.all([con.teams.read(), con.teams.debaters.read(), con.teams.debaters.read(), con.teams.results.read(), con.debaters.results.read(), con.rounds.read()]).then(function (vs) { var [teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, round_info] = vs return op.teams.results.summarize(teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, round_info.style, r_or_rs) }) } } } /** * Interfaces related to teams to debaters * @namespace debaters * @memberof teams */ /** * returns teams to debaters(No side effect) * @name teams.debaters.read * @memberof! teams.debaters * @function teams.debaters.read * @return {Promise} Teams to debaters */ /** * sets debaters to a team. * Attention: It throws an error if the specified team has debaters. * @name teams.debaters.create * @memberof! teams.debaters * @function teams.debaters.create * @param dict * @param {Number} dict.id id of the team to set debaters * @param {Number} dict.debaters debaters to set * @return {Promise} Created team * @throws {Promise} AlreadyExists */ /** * deletes debaters from specified team. * Attention: It throws an error if the specified team does not exist. * @name teams.debaters.delete * @memberof! teams.debaters * @function teams.debaters.delete * @param dict * @param {Number} dict.id id of the team to delete * @return {Promise} Team * @throws {Promise} DoesNotExist */ /** * finds on specified condition(No side effect) * @name teams.debaters.find * @memberof! teams * @function teams.debaters.find * @param dict * @param {Number} [dict.id] id of the team * @param {Number} [dict.debaters] debaters of the team * @return {Promise} Teams */ /** * updates debaters of specified team * Attention: It throws an error if the specified team does not exist. * @name teams.debaters.update * @memberof! teams.debaters * @function teams.debaters.update * @param dict * @param {Number} dict.id id of the team * @param {Number} [dict.debaters] debaters of the team * @return {Promise} Team * @throws DoesNotExist */ /** * Provides interefaces related to teams to institutions */ /** * Provides interfaces related to adjudicators * @namespace adjudicators */ var adjudicators = con.adjudicators /** * @namespace adjudicators.results * @memberof adjudicators */ /** * Summarizes adjudicator results(No side effect) * @alias adjudicators.results.organize * @memberof! adjudicators.results * @param {(Number | Number[])} r_or_rs round number(s) used to summarize results * @return {Promise} summarized adjudicator results */ adjudicators.results.organize = function(r_or_rs) { if (Array.isArray(r_or_rs)) { return Promise.all([con.adjudicators.read(), con.adjudicators.results.read()]).then(function(vs) { var [adjudicators, raw_adjudicator_results] = vs return op.adjudicators.results.compile(adjudicators, raw_adjudicator_results, r_or_rs) }) } else { return Promise.all([con.adjudicators.read(), con.adjudicators.results.read()]).then(function(vs) { var [adjudicators, raw_adjudicator_results] = vs return op.adjudicators.results.summarize(adjudicators, raw_adjudicator_results, r_or_rs) }) } } /** * Interfaces related to tournament operation * @namespace rounds * @deprecated */ var rounds = con.rounds /** * Interfaces related to venues * @namespace venues */ var venues = con.venues /** * Interfaces related to debaters * @namespace debaters */ var debaters = con.debaters /** * Interfaces related to debater results * @namespace debaters.results * @memberof debaters */ /** * Summarizes debater results(No side effect) * @alias adjudicators.results.organize * @memberof! adjudicators.results * @param {(Number | Number[])} r_or_rs round number(s) used to summarize results * @return {Promise} summarized adjudicator results */ debaters.results.organize = function(r_or_rs) { if (Array.isArray(r_or_rs)) { return Promise.all([con.debaters.read(), con.debaters.results.read()]).then(function(vs) { var [debaters, raw_debater_results] = vs return op.debaters.results.compile(debaters, raw_debater_results, r_or_rs) }) } else { return Promise.all([con.debaters.read(), con.debaters.results.read()]).then(function(vs) { var [debaters, raw_debater_results] = vs return op.debaters.results.summarize(debaters, raw_debater_results, r_or_rs) }) } } /** * Interfaces related to institutions * @namespace institutions */ var institutions = con.institutions /** * Provides interfaces related to allocations * @namespace allocations */ var allocations = {//op.allocations /** * get allocation(No side effect) * @alias allocations.get * @memberof! allocations * @param dict * @param {Boolean} dict.simple Does not use debater results * @param {Boolean} dict.with_venues Allocate venues * @param {Boolean} dict.with_adjudicators Allocate adjudicators * @param {String[]} dict.filters filters to use on computing team allocation * @param {String[]} dict.adjudicator_filters filters on computing adjudicator allocation * @param {Square[]} [allocation] team allocation by which it creates adjudicator/venue allocation if indicated * @return {Promise.&lt;Square[]&gt;} allocation */ get: function({ simple: simple = false, with_venues: with_venues = true, with_adjudicators: with_adjudicators = true, filters: filter_functions_strs=['by_strength', 'by_side', 'by_past_opponent', 'by_institution'], adjudicator_filters: filter_functions_adj_strs=['by_bubble', 'by_strength', 'by_attendance', 'by_conflict', 'by_institution', 'by_past'] }, allocation) { try { var all_filter_functions = op.allocations.teams.functions.read() var [all_filter_functions_adj, all_filter_functions_adj2] = op.allocations.adjudicators.functions.read() var filter_functions = filter_functions_strs.map(f_str =&gt; all_filter_functions[f_str]) var filter_functions_adj = filter_functions_adj_strs.filter(f_str =&gt; all_filter_functions_adj.hasOwnProperty(f_str)).map(f_str =&gt; all_filter_functions_adj[f_str]) var filter_functions_adj2 = filter_functions_adj_strs.filter(f_str =&gt; all_filter_functions_adj2.hasOwnProperty(f_str)).map(f_str =&gt; all_filter_functions_adj2[f_str]) } catch(e) { return Promise.reject(e) } if (simple === true) { if (allocation) { undefined } else { undefined } } else { if (allocation) { return con.rounds.read().then(function (round_info) { var current_round_num = round_info.current_round_num var considering_rounds = _.range(1, current_round_num) return Promise.all([con.teams.read(), con.adjudicators.read(), con.venues.read(), core.teams.results.organize(considering_rounds), core.adjudicators.results.organize(considering_rounds), con.adjudicators.institutions.read(), con.adjudicators.conflicts.read()]).then(function (vs) { var [teams, adjudicators, venues, compiled_team_results, compiled_adjudicator_results, adjudicators_to_institutions, adjudicators_to_conflicts] = vs if (with_adjudicators) { new_allocation = op.allocations.adjudicators.get(allocation, teams, adjudicators, compiled_team_results, compiled_adjudicator_results, adjudicators_to_institutions, adjudicators_to_conflicts, filter_functions_adj, filter_functions_adj2) } if (with_venues) { new_allocation = op.allocations.venues.get(new_allocation, venues) } return new_allocation }) }) } else { return con.rounds.read().then(function (round_info) { var current_round_num = round_info.current_round_num var considering_rounds = _.range(1, current_round_num) return Promise.all([con.teams.read(), con.adjudicators.read(), con.venues.read(), core.teams.results.organize(considering_rounds), core.adjudicators.results.organize(considering_rounds), con.teams.institutions.read(), con.adjudicators.institutions.read(), con.adjudicators.conflicts.read()]).then(function (vs) { var [teams, adjudicators, venues, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts] = vs var new_allocation = op.allocations.teams.get(teams, compiled_team_results, teams_to_institutions, filter_functions)/////// if (with_adjudicators) { new_allocation = op.allocations.adjudicators.get(new_allocation, teams, adjudicators, compiled_team_results, compiled_adjudicator_results, adjudicators_to_institutions, adjudicators_to_conflicts, filter_functions_adj, filter_functions_adj2) } if (with_venues) { new_allocation = op.allocations.venues.get(new_allocation, venues) } return new_allocation }) }) } } }, /** * checks allocation(No side effect) * @param dict * @param {Boolean} [dict.check_teams=true] check team allocation * @param {Boolean} [dict.check_adjudicators=true] check adjudicator allocation * @param {Boolean} [dict.check_venues=true] check venue allocation * @return {Promise.&lt;Square[]&gt;} */ check: function({ check_teams: check_teams = true, check_adjudicators: check_adjudicators = true, check_venues: check_venues = true }) { throw new Error('undefined') } } exports.connect = connect exports.close = close exports.tournaments = tournaments exports.teams = teams exports.adjudicators = adjudicators exports.venues = venues exports.rounds = rounds exports.debaters = debaters exports.institutions = institutions exports.allocations = allocations × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Global Methods close() close connection on tournament database Source: core.js, line 167 connect(id) connects to tournament database specified Parameters: Name Type Description id Number unique id of the tournament Source: core.js, line 161 Type Definitions Adjudicator Represents an adjudicator. Properties: Name Type Description id Number id of the Adjudicator preev Number pre evaluation(judge test) of the Adjudicator name String name of the Adjudicator available Boolean available url String url of the Adjudicator Source: core.js, line 46 Institution Represents an institution. Properties: Name Type Description id Number id of the Institution name String name of the Institution available Boolean available url String url of the Institution Source: core.js, line 66 RawAdjudicatorResult Represents raw adjudicator result. Properties: Name Type Argument Description id Number id of the adjudicator to evaluate from_id Number id of the sender r Number round number at which the result is sent score Number the score of the adjudicator the sender writes watched_teams Array.&lt;Number&gt; teams the adjudicator watched comment String &lt;optional&gt; the comment for the adjudicator from the sender Source: core.js, line 111 RawDebaterResult Represents raw debater result. Properties: Name Type Description id Number id of the debater to evaluate from_id Number id of the sender r Number round number at which the result is sent scores Array.&lt;Number&gt; scores the sender writes Source: core.js, line 95 Example { id: 1, from_id: 2, r: 1, scores: [75, 0, 36.5] } RawTeamResult Represents raw team result. Properties: Name Type Description id Number id of the team to evaluate from_id Number id of the sender r Number round number at which the result is sent win Number in NA it's either 1(win) or 0(lose), in BP it's the win-points opponents Array.&lt;Number&gt; opponents of the team side String side of the team Source: core.js, line 75 Example { id: 1, from_id: 2, r: 1, win: 1, opponents: [2], side: &quot;gov&quot; } Square Represents a pair/set of teams in a venue. A minimum unit to be an allocation. Properties: Name Type Description id Number id of the Square teams Array.&lt;Number&gt; teams in the Square chairs Array.&lt;Number&gt; chairs in the Square remaining_adjudicators Array.&lt;Number&gt; adjudicators(panels) in the Square remaining_adjudicators2 Array.&lt;Number&gt; adjudicators(trainees) in the Square warnings Array.&lt;String&gt; warnings venue Number Source: core.js, line 25 Style Represents debate style. Properties: Name Type Description name String style name debater_num_per_team Number number of debaters per team team_num Number number of team in a Square score_weights Array.&lt;Number&gt; weights of the scores replies Number candidates of replies (Necessary only for testing) reply_num Number number of replies in a Square (Necessary only for testing) Source: core.js, line 122 Example { name: &quot;ASIAN&quot;, debater_num_per_team: 3, team_num: 2, score_weights: [1, 1, 1, 0.5], replies: [0, 1], reply_num: 1 } Team Represents a team. Properties: Name Type Description id Number id of the Team name String name of the Team available Boolean available url String url of the Team Source: core.js, line 37 Tournament Represents a tournament. Properties: Name Type Description id Number id of the tournament name String name of the tournament url String url of the tournament current_round_num Number current round total_round_num Number total round style Style style of the tournament Source: core.js, line 142 Venue Represents a venue. Properties: Name Type Description id Number id of the Venue priority Number priority of the Venue name String name of the Venue available Boolean available url String url of the Venue Source: core.js, line 56 × Search results Close "},"namespaces.list.html":{"id":"namespaces.list.html","title":"Namespaces","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespaces Namespaces adjudicators results allocations debaters results institutions rounds teams debaters results tournaments venues × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Index core.js Interfaces to manage tournament Version: 1.1 Author: taulukointipalvelut@gmail.com (nswa17) Source: core.js, line 2 To Do: simple allocation Example var core = require('./core.js') var t_id = 234234 core.tournaments.read().then(console.log) //print all tournaments core.tournaments.create({id: t_id, name: &quot;testtournament&quot;}) core.connect(t_id) core.teams.read().then(console.log) //print all teams × Search results Close "},"adjudicators.html":{"id":"adjudicators.html","title":"Namespace: adjudicators","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: adjudicators adjudicators Provides interfaces related to adjudicators Source: core.js, line 371 Namespaces results × Search results Close "},"adjudicators.results.html":{"id":"adjudicators.results.html","title":"Namespace: results","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: results adjudicators. results Source: core.js, line 376 Methods .organize(r_or_rs) Summarizes debater results(No side effect) Parameters: Name Type Description r_or_rs Number | Array.&lt;Number&gt; round number(s) used to summarize results Source: core.js, line 429 Returns: summarized adjudicator results Type Promise .organize(r_or_rs) Summarizes adjudicator results(No side effect) Parameters: Name Type Description r_or_rs Number | Array.&lt;Number&gt; round number(s) used to summarize results Source: core.js, line 387 Returns: summarized adjudicator results Type Promise × Search results Close "},"allocations.html":{"id":"allocations.html","title":"Namespace: allocations","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: allocations allocations Provides interfaces related to allocations Source: core.js, line 448 Methods &lt;static&gt; check(dict) checks allocation(No side effect) Parameters: Name Type Description dict Properties Name Type Argument Default Description check_teams Boolean &lt;optional&gt; true check team allocation check_adjudicators Boolean &lt;optional&gt; true check adjudicator allocation check_venues Boolean &lt;optional&gt; true check venue allocation Source: core.js, line 533 Returns: Type Promise.&lt;Array.&lt;Square&gt;&gt; .get(dict [, allocation]) get allocation(No side effect) Parameters: Name Type Argument Description dict Properties Name Type Description simple Boolean Does not use debater results with_venues Boolean Allocate venues with_adjudicators Boolean Allocate adjudicators filters Array.&lt;String&gt; filters to use on computing team allocation adjudicator_filters Array.&lt;String&gt; filters on computing adjudicator allocation allocation Array.&lt;Square&gt; &lt;optional&gt; team allocation by which it creates adjudicator/venue allocation if indicated Source: core.js, line 466 Returns: allocation Type Promise.&lt;Array.&lt;Square&gt;&gt; × Search results Close "},"debaters.html":{"id":"debaters.html","title":"Namespace: debaters","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: debaters debaters Interfaces related to debaters Source: core.js, line 412 Namespaces results × Search results Close "},"debaters.results.html":{"id":"debaters.results.html","title":"Namespace: results","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: results debaters. results Interfaces related to debater results Source: core.js, line 417 × Search results Close "},"institutions.html":{"id":"institutions.html","title":"Namespace: institutions","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: institutions institutions Interfaces related to institutions Source: core.js, line 442 × Search results Close "},"rounds.html":{"id":"rounds.html","title":"Namespace: rounds","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: rounds rounds Interfaces related to tournament operation Deprecated: Yes Source: core.js, line 401 × Search results Close "},"teams.html":{"id":"teams.html","title":"Namespace: teams","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: teams teams Provides Interfaces related to teams Source: core.js, line 197 Namespaces debaters results Methods .create(dict) creates specified team.Attention: It throws an error if the specified team already exists. Parameters: Name Type Description dict Properties Name Type Argument Default Description id Number id of the team to create name Number &lt;optional&gt; &quot;&quot; name of the team to create available Number &lt;optional&gt; true id of the team to create url Number &lt;optional&gt; &quot;&quot; id of the team to create Source: core.js, line 210 Throws: AlreadyExists Type Promise Returns: Created team Type Promise.&lt;Team&gt; .debaters.find(dict) finds on specified condition(No side effect) Parameters: Name Type Description dict Properties Name Type Argument Description id Number &lt;optional&gt; id of the team debaters Number &lt;optional&gt; debaters of the team Source: core.js, line 344 Returns: Teams Type Promise .delete(dict) deletes specified team.Attention: It throws an error if the specified team does not exist. Parameters: Name Type Description dict Properties Name Type Description id Number id of the team to delete Source: core.js, line 225 Throws: DoesNotExist Type Promise Returns: Deleted team Type Promise.&lt;Team&gt; .find(dict) finds on specified condition(No side effect) Parameters: Name Type Description dict Properties Name Type Argument Description id Number &lt;optional&gt; id of the team to find name Number &lt;optional&gt; name of the team to find available Number &lt;optional&gt; id of the team to find url Number &lt;optional&gt; id of the team to find Source: core.js, line 236 Returns: Teams Type Promise.&lt;Array.&lt;Team&gt;&gt; .read() returns all teams(No side effect) Source: core.js, line 202 Returns: Teams Type Promise.&lt;Array.&lt;Team&gt;&gt; .update(dict) updates specified teamAttention: It throws an error if the specified team does not exist. Parameters: Name Type Description dict Properties Name Type Argument Default Description id Number id of the team to update name Number &lt;optional&gt; &quot;&quot; name of the team to update available Number &lt;optional&gt; true id of the team to update url Number &lt;optional&gt; &quot;&quot; id of the team to update Source: core.js, line 248 Throws: DoesNotExist Returns: Updated team Type Promise.&lt;Team&gt; × Search results Close "},"teams.debaters.html":{"id":"teams.debaters.html","title":"Namespace: debaters","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: debaters teams. debaters Interfaces related to teams to debaters Source: core.js, line 309 Methods .create(dict) sets debaters to a team.Attention: It throws an error if the specified team has debaters. Parameters: Name Type Description dict Properties Name Type Description id Number id of the team to set debaters debaters Number debaters to set Source: core.js, line 321 Throws: AlreadyExists Type Promise Returns: Created team Type Promise .delete(dict) deletes debaters from specified team.Attention: It throws an error if the specified team does not exist. Parameters: Name Type Description dict Properties Name Type Description id Number id of the team to delete Source: core.js, line 333 Throws: DoesNotExist Type Promise Returns: Team Type Promise .read() returns teams to debaters(No side effect) Source: core.js, line 314 Returns: Teams to debaters Type Promise .update(dict) updates debaters of specified teamAttention: It throws an error if the specified team does not exist. Parameters: Name Type Description dict Properties Name Type Argument Description id Number id of the team debaters Number &lt;optional&gt; debaters of the team Source: core.js, line 354 Throws: DoesNotExist Returns: Team Type Promise × Search results Close "},"teams.results.html":{"id":"teams.results.html","title":"Namespace: results","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: results teams. results Source: core.js, line 262 Methods &lt;static&gt; organize(r_or_rs, options) Summarizes team results(No side effect) Parameters: Name Type Description r_or_rs Number | Array.&lt;Number&gt; round number(s) used to summarize results options options for summarization Properties Name Type Description simple Boolean only use team results. No debater results is considered thus unable to output team points Source: core.js, line 281 Returns: summarized team results Type Promise .read() reads all raw team results(No side effect) Source: core.js, line 266 Returns: Type Promise.&lt;Array.&lt;RawTeamResult&gt;&gt; × Search results Close "},"tournaments.html":{"id":"tournaments.html","title":"Namespace: tournaments","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: tournaments tournaments Provides Interfaces related to tournaments Source: core.js, line 171 Members .read Source: core.js, line 175 Methods .create() Source: core.js, line 180 .delete() Source: core.js, line 190 .update() Source: core.js, line 185 × Search results Close "},"venues.html":{"id":"venues.html","title":"Namespace: venues","body":" DocStrap Namespaces adjudicatorsadjudicators.resultsallocationsdebatersdebaters.resultsinstitutionsroundsteamsteams.debatersteams.resultstournamentsvenues Global closeconnect Namespace: venues venues Interfaces related to venues Source: core.js, line 407 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
