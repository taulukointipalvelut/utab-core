<!DOCTYPE html>

<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>DocStrap Source: core.js</title>

	<!--[if lt IE 9]>
	<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
	<link type="text/css" rel="stylesheet" href="styles/sunlight.default.css">

	<link type="text/css" rel="stylesheet" href="styles/site.paper.css">

</head>

<body>

<div class="navbar navbar-default navbar-fixed-top navbar-inverse">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href="index.html">DocStrap</a>
		<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
        </button>
	</div>
	<div class="navbar-collapse collapse" id="topNavigation">
		<ul class="nav navbar-nav">
			
			<li class="dropdown">
				<a href="namespaces.list.html" class="dropdown-toggle" data-toggle="dropdown">Namespaces<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="adjudicators.html">adjudicators</a></li><li><a href="adjudicators.results.html">adjudicators.results</a></li><li><a href="allocations.html">allocations</a></li><li><a href="debaters.html">debaters</a></li><li><a href="debaters.results.html">debaters.results</a></li><li><a href="institutions.html">institutions</a></li><li><a href="rounds.html">rounds</a></li><li><a href="teams.html">teams</a></li><li><a href="teams.debaters.html">teams.debaters</a></li><li><a href="teams.results.html">teams.results</a></li><li><a href="venues.html">venues</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="classes.list.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="Main.html">Main</a></li>
				</ul>
			</li>
			
			<li class="dropdown">
				<a href="global.html" class="dropdown-toggle" data-toggle="dropdown">Global<b class="caret"></b></a>
				<ul class="dropdown-menu ">
					<li><a href="global.html">Global</a></li>
				</ul>
			</li>
			
		</ul>
        
            <div class="col-sm-3 col-md-3">
                <form class="navbar-form" role="search">
                    <div class="input-group">
                        <input type="text" class="form-control" placeholder="Search" name="q" id="search-input">
                        <div class="input-group-btn">
                            <button class="btn btn-default" id="search-submit"><i class="glyphicon glyphicon-search"></i></button>
                        </div>
                    </div>
                </form>
            </div>
        
	</div>

</div>
</div>


<div class="container" id="toc-content">
<div class="row">

	
	<div class="col-md-12">
	
		<div id="main">
			

		<h1 class="page-title">Source: core.js</h1>
    
<section>
    <article>
        <pre
            class="sunlight-highlight-javascript linenums">"use strict";
/**
 * @author taulukointipalvelut@gmail.com (nswa17)
 * @file Interfaces to manage tournament
 * @todo simple allocation
 * @version 1.1
 */

var operations = require('./src/operations.js')
var controllers = require('./src/controllers.js')
var _ = require('underscore/underscore.js')

/**
 * Represents a pair/set of teams in a venue. A minimum unit to be an allocation.
 * @typedef Square
 * @property {Number} id id of the Square
 * @property {Number[]} teams teams in the Square
 * @property {Number[]} chairs chairs in the Square
 * @property {Number[]} remaining_adjudicators adjudicators(panels) in the Square
 * @property {Number[]} remaining_adjudicators2 adjudicators(trainees) in the Square
 * @property {String[]} warnings warnings
 * @property {Number} venue
 */

 /**
  * Represents a team.
  * @typedef Team
  * @property {Number} id id of the Team
  * @property {String} name name of the Team
  * @property {Boolean} available available
  * @property {String} url url of the Team
  */

  /**
   * Represents an adjudicator.
   * @typedef Adjudicator
   * @property {Number} id id of the Adjudicator
   * @property {Number} preev pre evaluation(judge test) of the Adjudicator
   * @property {String} name name of the Adjudicator
   * @property {Boolean} available available
   * @property {String} url url of the Adjudicator
   */

/**
 * Represents a venue.
 * @typedef Venue
 * @property {Number} id id of the Venue
 * @property {Number} priority priority of the Venue
 * @property {String} name name of the Venue
 * @property {Boolean} available available
 * @property {String} url url of the Venue
 */

/**
 * Represents an institution.
 * @typedef Institution
 * @property {Number} id id of the Institution
 * @property {String} name name of the Institution
 * @property {Boolean} available available
 * @property {String} url url of the Institution
 */

 /**
  * Represents raw team result.
  * @typedef RawTeamResult
  * @property {Number} id id of the team to evaluate
  * @property {Number} from_id id of the sender
  * @property {Number} r round number at which the result is sent
  * @property {Number} win in NA it's either 1(win) or 0(lose), in BP it's the win-points
  * @property {Number[]} opponents opponents of the team
  * @property {String} side side of the team
  * @example
  * {
  *   id: 1,
  *   from_id: 2,
  *   r: 1,
  *   win: 1,
  *   opponents: [2],
  *   side: "gov"
  * }
  */

/**
* Represents raw debater result.
* @typedef RawDebaterResult
* @property {Number} id id of the debater to evaluate
* @property {Number} from_id id of the sender
* @property {Number} r round number at which the result is sent
* @property {Number[]} scores scores the sender writes
* @example
* {
*   id: 1,
*   from_id: 2,
*   r: 1,
*   scores: [75, 0, 36.5]
* }
*/

/**
 * Represents raw adjudicator result.
 * @typedef RawAdjudicatorResult
 * @property {Number} id id of the adjudicator to evaluate
 * @property {Number} from_id id of the sender
 * @property {Number} r round number at which the result is sent
 * @property {Number} score the score of the adjudicator the sender writes
 * @property {Number[]} watched_teams teams the adjudicator watched
 * @property {String} [comment] the comment for the adjudicator from the sender
 */

/**
 * Interfaces to operate UTab core
 */
class Main {
    /**
     * @param {(String | Number)} id - Unique ID of the tournament
     */
    constructor (id) {
        var con = new controllers.CON(id)
        var op = new operations.OP()

        var core = this
        /**
         * Provides Interfaces related to teams
         * @namespace teams
         */
        this.teams = con.teams
        /**
         * returns all teams(No side effect)
         * @name teams.read
         * @memberof! teams
         * @function teams.read
         * @return {Promise.&lt;Team[]>} Teams
         */
        //this.teams.read
        /**
         * creates specified team.
         * Attention: It throws an error if the specified team already exists.
         * @name teams.create
         * @memberof! teams
         * @function teams.create
         * @param dict
         * @param {Number} dict.id id of the team to create
         * @param {Number} [dict.name=""] name of the team to create
         * @param {Number} [dict.available=true] id of the team to create
         * @param {Number} [dict.url=""] id of the team to create
         * @return {Promise.&lt;Team>} Created team
         * @throws {Promise} AlreadyExists
         */
        //this.teams.create
        /**
         * deletes specified team.
         * Attention: It throws an error if the specified team does not exist.
         * @name teams.delete
         * @memberof! teams
         * @function teams.delete
         * @param dict
         * @param {Number} dict.id id of the team to delete
         * @return {Promise.&lt;Team>} Deleted team
         * @throws {Promise} DoesNotExist
         */
        /**
         * finds on specified condition(No side effect)
         * @name teams.find
         * @memberof! teams
         * @function teams.find
         * @param dict
         * @param {Number} [dict.id] id of the team to find
         * @param {Number} [dict.name] name of the team to find
         * @param {Number} [dict.available] id of the team to find
         * @param {Number} [dict.url] id of the team to find
         * @return {Promise.&lt;Team[]>} Teams
         */
        /**
         * updates specified team
         * Attention: It throws an error if the specified team does not exist.
         * @name teams.update
         * @memberof! teams
         * @function teams.update
         * @param dict
         * @param {Number} dict.id id of the team to update
         * @param {Number} [dict.name=""] name of the team to update
         * @param {Number} [dict.available=true] id of the team to update
         * @param {Number} [dict.url=""] id of the team to update
         * @return {Promise.&lt;Team>} Updated team
         * @throws DoesNotExist
         */
        /**
         * @namespace teams.results
         * @memberof teams
         */
        /**
         * reads all raw team results(No side effect)
         * @name teams.results.read
         * @memberof! teams.results
         * @function teams.results.read
         * @returns {Promise.&lt;RawTeamResult[]>}
         */
        /**
         * Summarizes team results(No side effect)
         * @alias teams.results.organize
         * @param  {(Number | Number[])} r_or_rs round number(s) used to summarize results
         * @param options options for summarization
         * @param {Boolean} options.simple only use team results. No debater results is considered thus unable to output team points
         * @return {Promise} summarized team results
         */
        this.teams.results.organize = function(r_or_rs, {simple: simple}={simple: false}) {
            if (simple) {
                if (Array.isArray(r_or_rs)) {
                    return Promise.all([con.teams.read(), con.teams.results.read()]).then(function (vs) {
                        var [teams, raw_team_results] = vs
                        return op.teams.results.simplified_compile(teams, raw_team_results, r_or_rs)
                    })
                } else {
                    return Promise.all([con.teams.read(), con.teams.results.read()]).then(function (vs) {
                        var [teams, raw_team_results] = vs
                        return op.teams.results.simplified_summarize(teams, raw_team_results, r_or_rs)
                    })
                }
            } else {
                if (Array.isArray(r_or_rs)) {
                    return Promise.all([con.teams.read(), con.teams.debaters.read(), con.teams.debaters.read(), con.teams.results.read(), con.debaters.results.read(), con.rounds.styles.read()]).then(function (vs) {
                        var [teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, style] = vs
                        return op.teams.results.compile(teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, style, r_or_rs)
                    })
                } else {
                    return Promise.all([con.teams.read(), con.teams.debaters.read(), con.teams.debaters.read(), con.teams.results.read(), con.debaters.results.read(), con.rounds.styles.read()]).then(function (vs) {
                        var [teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, style] = vs
                        return op.teams.results.summarize(teams, debaters, teams_to_debaters, raw_team_results, raw_debater_results, style, r_or_rs)
                    })
                }
            }
        }

        /**
         * Interfaces related to teams to debaters
         * @namespace debaters
         * @memberof teams
         */
        /**
         * returns teams to debaters(No side effect)
         * @name teams.debaters.read
         * @memberof! teams.debaters
         * @function teams.debaters.read
         * @return {Promise} Teams to debaters
         */
        /**
         * sets debaters to a team.
         * Attention: It throws an error if the specified team has debaters.
         * @name teams.debaters.create
         * @memberof! teams.debaters
         * @function teams.debaters.create
         * @param dict
         * @param {Number} dict.id id of the team to set debaters
         * @param {Number} dict.debaters debaters to set
         * @return {Promise} Created team
         * @throws {Promise} AlreadyExists
         */
        /**
         * sets debaters to a team. It does not throw an error even if debaters are already set to the team.
         * @name teams.debaters.createIfNotExists
         * @memberof! teams.debaters
         * @function teams.debaters.createIfNotExists
         * @param dict
         * @param {Number} dict.id id of the team to set debaters
         * @param {Number} dict.debaters debaters to set
         * @return {Promise} Created team
         */
        /**
         * deletes debaters from specified team.
         * Attention: It throws an error if the specified team does not exist.
         * @name teams.debaters.delete
         * @memberof! teams.debaters
         * @function teams.debaters.delete
         * @param dict
         * @param {Number} dict.id id of the team to delete
         * @return {Promise} Team
         * @throws {Promise} DoesNotExist
         */
        /**
         * finds on specified condition(No side effect)
         * @name teams.debaters.find
         * @memberof! teams
         * @function teams.debaters.find
         * @param dict
         * @param {Number} [dict.id] id of the team
         * @param {Number} [dict.debaters] debaters of the team
         * @return {Promise} Teams
         */
        /**
         * updates debaters of specified team
         * Attention: It throws an error if the specified team does not exist.
         * @name teams.debaters.update
         * @memberof! teams.debaters
         * @function teams.debaters.update
         * @param dict
         * @param {Number} dict.id id of the team
         * @param {Number} [dict.debaters] debaters of the team
         * @return {Promise} Team
         * @throws DoesNotExist
         */

        /**
         * Provides interefaces related to teams to institutions
         */

        /**
         * Provides interfaces related to adjudicators
         * @namespace adjudicators
         */
        this.adjudicators = con.adjudicators
        /**
         * @namespace adjudicators.results
         * @memberof adjudicators
         */
        /**
         * Summarizes adjudicator results(No side effect)
         * @alias adjudicators.results.organize
         * @memberof! adjudicators.results
         * @param  {(Number | Number[])} r_or_rs round number(s) used to summarize results
         * @return {Promise} summarized adjudicator results
         */
        this.adjudicators.results.organize = function(r_or_rs) {
            if (Array.isArray(r_or_rs)) {

                return Promise.all([con.adjudicators.read(), con.adjudicators.results.read()]).then(function(vs) {
                    var [adjudicators, raw_adjudicator_results] = vs
                    return op.adjudicators.results.compile(adjudicators, raw_adjudicator_results, r_or_rs)
                })
            } else {
                return Promise.all([con.adjudicators.read(), con.adjudicators.results.read()]).then(function(vs) {
                    var [adjudicators, raw_adjudicator_results] = vs
                    return op.adjudicators.results.summarize(adjudicators, raw_adjudicator_results, r_or_rs)
                })
            }
        }
        /**
         * Interfaces related to tournament operation
         * @namespace rounds
         * @deprecated
         */
        this.rounds = con.rounds
        /**
         * Interfaces related to venues
         * @namespace venues
         */
        this.venues = con.venues
        /**
         * Interfaces related to debaters
         * @namespace debaters
         */
        this.debaters = con.debaters
        /**
         * Interfaces related to debater results
         * @namespace debaters.results
         * @memberof debaters
         */
        /**
         * Summarizes debater results(No side effect)
         * @alias adjudicators.results.organize
         * @memberof! adjudicators.results
         * @param  {(Number | Number[])} r_or_rs round number(s) used to summarize results
         * @return {Promise} summarized adjudicator results
         */
        this.debaters.results.organize = function(r_or_rs) {
            if (Array.isArray(r_or_rs)) {
                return Promise.all([con.debaters.read(), con.debaters.results.read()]).then(function(vs) {
                    var [debaters, raw_debater_results] = vs
                    return op.debaters.results.compile(debaters, raw_debater_results, r_or_rs)
                })
            } else {
                return Promise.all([con.debaters.read(), con.debaters.results.read()]).then(function(vs) {
                    var [debaters, raw_debater_results] = vs
                    return op.debaters.results.summarize(debaters, raw_debater_results, r_or_rs)
                })
            }
        }
        /**
         * Interfaces related to institutions
         * @namespace institutions
         */
        this.institutions = con.institutions

        /**
         * Provides interfaces related to allocations
         * @namespace allocations
         */
        this.allocations = {//op.allocations
            /**
             * get allocation(No side effect)
             * @alias allocations.get
             * @memberof! allocations
             * @param {Grids}  dict
             * @param  {Boolean} dict.simple Does not use debater results
             * @param  {Boolean} dict.with_venues Allocate venues
             * @param  {Boolean} dict.with_adjudicators Allocate adjudicators
             * @param  {String[]} dict.filters filters to use on computing team allocation
             * @param  {String[]} dict.adjudicator_filters filters on computing adjudicator allocation
             * @param  {Square} [allocation] team allocation by which it creates adjudicator/venue allocation if indicated
             * @return {Promise.&lt;Square[]>} allocation
             */
            get: function({
                    simple: simple = false,
                    with_venues: with_venues = true,
                    with_adjudicators: with_adjudicators = true,
                    filters: filter_functions_strs=['by_strength', 'by_side', 'by_past_opponent', 'by_institution'],
                    adjudicator_filters: filter_functions_adj_strs=['by_bubble', 'by_strength', 'by_attendance', 'by_conflict', 'by_institution', 'by_past']
                }, allocation) {
                try {
                    var all_filter_functions = op.allocations.teams.functions.read()
                    var [all_filter_functions_adj, all_filter_functions_adj2] = op.allocations.adjudicators.functions.read()
                    var filter_functions = filter_functions_strs.map(f_str => all_filter_functions[f_str])
                    var filter_functions_adj = filter_functions_adj_strs.filter(f_str => all_filter_functions_adj.hasOwnProperty(f_str)).map(f_str => all_filter_functions_adj[f_str])
                    var filter_functions_adj2 = filter_functions_adj_strs.filter(f_str => all_filter_functions_adj2.hasOwnProperty(f_str)).map(f_str => all_filter_functions_adj2[f_str])
                } catch(e) {
                    return Promise.reject(e)
                }
                if (simple === true) {
                    if (allocation) {
                        undefined
                    } else {
                        undefined
                    }
                } else {
                    if (allocation) {
                        return con.rounds.read().then(function (round_info) {
                            var current_round_num = round_info['current_round_num']
                            var considering_rounds = _.range(1, current_round_num)
                            return Promise.all([con.teams.read(), con.adjudicators.read(), con.venues.read(), core.teams.results.organize(considering_rounds), core.adjudicators.results.organize(considering_rounds), con.adjudicators.institutions.read(), con.adjudicators.conflicts.read()]).then(function (vs) {
                                var [teams, adjudicators, venues, compiled_team_results, compiled_adjudicator_results, adjudicators_to_institutions, adjudicators_to_conflicts] = vs

                                if (with_adjudicators) {
                                    new_allocation = op.allocations.adjudicators.get(allocation, teams, adjudicators, compiled_team_results, compiled_adjudicator_results, adjudicators_to_institutions, adjudicators_to_conflicts, filter_functions_adj, filter_functions_adj2)
                                }
                                if (with_venues) {
                                    new_allocation = op.allocations.venues.get(new_allocation, venues)
                                }
                                return new_allocation
                            })
                        })
                    } else {
                        return con.rounds.read().then(function (round_info) {
                            var current_round_num = round_info['current_round_num']
                            var considering_rounds = _.range(1, current_round_num)
                            return Promise.all([con.teams.read(), con.adjudicators.read(), con.venues.read(), core.teams.results.organize(considering_rounds), core.adjudicators.results.organize(considering_rounds), con.teams.institutions.read(), con.adjudicators.institutions.read(), con.adjudicators.conflicts.read()]).then(function (vs) {
                                var [teams, adjudicators, venues, compiled_team_results, compiled_adjudicator_results, teams_to_institutions, adjudicators_to_institutions, adjudicators_to_conflicts] = vs

                                var new_allocation = op.allocations.teams.get(teams, compiled_team_results, teams_to_institutions, filter_functions)///////
                                if (with_adjudicators) {
                                    new_allocation = op.allocations.adjudicators.get(new_allocation, teams, adjudicators, compiled_team_results, compiled_adjudicator_results, adjudicators_to_institutions, adjudicators_to_conflicts, filter_functions_adj, filter_functions_adj2)
                                }
                                if (with_venues) {
                                    new_allocation = op.allocations.venues.get(new_allocation, venues)
                                }
                                return new_allocation
                            })
                        })
                    }
                }
            },
            /**
             * checks allocation(No side effect)
             * @param dict
             * @param  {Boolean} [dict.check_teams=true] check team allocation
             * @param  {Boolean} [dict.check_adjudicators=true] check adjudicator allocation
             * @param  {Boolean} [dict.check_venues=true] check venue allocation
             * @return {Promise.&lt;Square[]>}
             */
            check: function({
                check_teams: check_teams = true,
                check_adjudicators: check_adjudicators = true,
                check_venues: check_venues = true
            }) {
                throw new Error('undefined')
            }
        }
        this.db = {
            close: con.close
        }
    }
}

exports.Main = Main
/*
var t = new Main( "test")
//console.log(t)

t.rounds.configure({total_round_num: 4})
t.teams.create({id: 1, institution_ids: [0]})
t.teams.create({id: 2, institution_ids: [0]})
t.teams.create({id: 3, institution_ids: [1]})
t.teams.create({id: 4, institution_ids: [1]})
t.adjudicators.create({id: 1, institution_ids: [0], conflicts: [1]})
t.adjudicators.create({id: 2, institution_ids: [2], conflicts: [3]})
t.venues.create({id: 1, priority: 1})
t.venues.create({id: 2, priority: 1})
console.log(t.teams.read({id: 1, institution_ids: [0, 1]}))
console.log(t.teams.read())
console.log(t.adjudicators.read({institution_ids: [0, 1]}))
console.log(t.allocations.read())
//console.log(t.teams.delete(1))
//console.log(t.teams.read)
*/
</pre>
    </article>
</section>





		</div>
	</div>

	<div class="clearfix"></div>

	

</div>
</div>


    <div class="modal fade" id="searchResults">
      <div class="modal-dialog">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
            <h4 class="modal-title">Search results</h4>
          </div>
          <div class="modal-body"></div>
          <div class="modal-footer">
            <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
          </div>
        </div><!-- /.modal-content -->
      </div><!-- /.modal-dialog -->
    </div>


<footer>


	<span class="copyright">
	DocStrap Copyright © 2012-2015 The contributors to the JSDoc3 and DocStrap projects.
	</span>

<span class="jsdoc-message">
	Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a>
	
		on Sun Nov 20th 2016
	
	using the <a href="https://github.com/docstrap/docstrap">DocStrap template</a>.
</span>
</footer>

<script src="scripts/docstrap.lib.js"></script>
<script src="scripts/toc.js"></script>

    <script type="text/javascript" src="scripts/fulltext-search-ui.js"></script>


<script>
$( function () {
	$( "[id*='$']" ).each( function () {
		var $this = $( this );

		$this.attr( "id", $this.attr( "id" ).replace( "$", "__" ) );
	} );

	$( ".tutorial-section pre, .readme-section pre, pre.prettyprint.source" ).each( function () {
		var $this = $( this );

		var example = $this.find( "code" );
		exampleText = example.html();
		var lang = /{@lang (.*?)}/.exec( exampleText );
		if ( lang && lang[1] ) {
			exampleText = exampleText.replace( lang[0], "" );
			example.html( exampleText );
			lang = lang[1];
		} else {
			var langClassMatch = example.parent()[0].className.match(/lang\-(\S+)/);
			lang = langClassMatch ? langClassMatch[1] : "javascript";
		}

		if ( lang ) {

			$this
			.addClass( "sunlight-highlight-" + lang )
			.addClass( "linenums" )
			.html( example.html() );

		}
	} );

	Sunlight.highlightAll( {
		lineNumbers : true,
		showMenu : true,
		enableDoclinks : true
	} );

	$.catchAnchorLinks( {
        navbarOffset: 10
	} );
	$( "#toc" ).toc( {
		anchorName  : function ( i, heading, prefix ) {
			return $( heading ).attr( "id" ) || ( prefix + i );
		},
		selectors   : "#toc-content h1,#toc-content h2,#toc-content h3,#toc-content h4",
		showAndHide : false,
		smoothScrolling: true
	} );

	$( "#main span[id^='toc']" ).addClass( "toc-shim" );
	$( '.dropdown-toggle' ).dropdown();

    $( "table" ).each( function () {
      var $this = $( this );
      $this.addClass('table');
    } );

} );
</script>



<!--Navigation and Symbol Display-->


<!--Google Analytics-->



    <script type="text/javascript">
        $(document).ready(function() {
            SearcherDisplay.init();
        });
    </script>


</body>
</html>
